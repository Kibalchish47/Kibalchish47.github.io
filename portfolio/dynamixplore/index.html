<!doctype html><html lang=en-us class=scroll-smooth><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Project 1 ‚Äì A Modular Framework for Numerical Exploration of Dynamical Systems (DynamiXplore) - Daniel Dia's Personal Website</title>
  
    
    
      
        
          <link rel="stylesheet" href="/css/main.a5fbb86e0238d23057b80a1fbf49984b592280010fad444978ea2148f9bd6b66.css" integrity="sha256-pfu4bgI40jBXuAofv0mYS1kigAEPrURJeOohSPm9a2Y=" crossorigin="anonymous">
        
      
    
  

<link rel=icon type=image/png href=/D2.png><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;700&display=swap" rel=stylesheet></head><body class="flex flex-col min-h-screen font-sans"><header class=site-header><meta property="og:title" content="Daniel Dia"><meta property="og:description" content="Computer & Communications Engineering student @AUB | Mathematics Enthusiast"><meta property="og:type" content="website"><meta property="og:url" content="https://kibalchish47.github.io/"><meta property="og:image" content="https://kibalchish47.github.io/social-preview.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Daniel Dia"><meta name=twitter:description content="Computer & Communications Engineering student @AUB | Mathematics Enthusiast"><meta name=twitter:image content="https://kibalchish47.github.io/social-preview.png"><div class="container mx-auto px-6 py-4 flex flex-col md:flex-row justify-between items-center"><a href=/ class="text-3xl font-bold mb-4 md:mb-0 text-custom-gray-800">Daniel Dia</a><nav class="flex flex-wrap justify-center md:space-x-1"><a href=/ class="nav-link px-5 py-2 text-custom-gray-700 hover:text-custom-red-500 hover:bg-custom-red-100 rounded-md transition-colors duration-300">Homepage</a>
<a href=/about/ class="nav-link px-5 py-2 text-custom-gray-700 hover:text-custom-red-500 hover:bg-custom-red-100 rounded-md transition-colors duration-300">About</a>
<a href=/portfolio/ class="nav-link px-5 py-2 text-custom-gray-700 hover:text-custom-red-500 hover:bg-custom-red-100 rounded-md transition-colors duration-300">Portfolio</a>
<a href=/blog/ class="nav-link px-5 py-2 text-custom-gray-700 hover:text-custom-red-500 hover:bg-custom-red-100 rounded-md transition-colors duration-300">Blog</a>
<a href=/publications/ class="nav-link px-5 py-2 text-custom-gray-700 hover:text-custom-red-500 hover:bg-custom-red-100 rounded-md transition-colors duration-300">Publications</a>
<a href=/contact/ class="nav-link px-5 py-2 text-custom-gray-700 hover:text-custom-red-500 hover:bg-custom-red-100 rounded-md transition-colors duration-300">Contact</a></nav></div></header><main class="container mx-auto px-6 py-8 flex-grow"><article class="p-6 bg-white rounded-xl shadow-lg"><header class="mb-8 text-center"><h1 class="text-4xl font-bold text-custom-red-500">Project 1 ‚Äì A Modular Framework for Numerical Exploration of Dynamical Systems (DynamiXplore)</h1><p class="text-sm text-custom-gray-600 mt-2">June 29, 2025</p><div class=mt-2><span class="inline-block bg-custom-red-100 text-custom-red-500 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">Dynamical Systems</span>
<span class="inline-block bg-custom-red-100 text-custom-red-500 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">FOSS</span>
<span class="inline-block bg-custom-red-100 text-custom-red-500 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">Research Software</span>
<span class="inline-block bg-custom-red-100 text-custom-red-500 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">Python</span>
<span class="inline-block bg-custom-red-100 text-custom-red-500 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">Rust</span>
<span class="inline-block bg-custom-red-100 text-custom-red-500 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">Simulation</span>
<span class="inline-block bg-custom-red-100 text-custom-red-500 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">In Progress</span></div></header><hr class=custom-divider><div class="prose prose-custom-red lg:prose-xl max-w-none prose-sm md:prose-base"><p>A modern, high-performance Python framework designed to provide a cohesive, end-to-end environment for the study of dynamical systems.</p><p>Features:</p><ul><li><p>High-Performance Core üöÄ: Backend written in Rust for C-level speed on intensive calculations.</p></li><li><p>Comprehensive Analysis Suite üìà: Includes Lyapunov exponents, permutation entropy, fractal dimensions, and more.</p></li><li><p>Pythonic API üêç: Designed to be intuitive and easy to integrate into the existing Python data science ecosystem.</p></li><li><p>Interactive Visualizations üåê: Built-in plotting functions using Plotly for easy exploration of results.</p></li></ul><h2 id=introduction>Introduction</h2><p>Scientists and engineers across disciplines ‚Äî from epidemiology and physics to economics and biology ‚Äî rely on the numerical exploration of dynamical systems to understand complex phenomena. This exploration typically involves a recurring workflow: defining a model&rsquo;s equations, simulating its behavior over time, and analyzing the resulting trajectory to uncover its fundamental properties, such as stability, periodicity, or the presence of chaos.</p><p>In the Python ecosystem, this process has traditionally been fragmented and inefficient. A researcher must often act as a software integrator, manually piecing together disparate tools: <code>SciPy</code>&rsquo;s powerful but general-purpose ODE solvers for simulation, specialized time-series libraries or custom-written scripts for computing metrics like Lyapunov exponents, and plotting libraries like <code>Matplotlib</code> to visualize the results. This not only complicates the research workflow but also introduces performance bottlenecks, as numerically intensive analysis in pure Python can be prohibitively slow for long simulations or high-dimensional systems.</p><p><code>DynamiXplore</code> was created to address these challenges directly. It is a modern, high-performance Python framework designed to provide a cohesive, end-to-end environment for the study of dynamical systems. Its mission is to streamline the entire research pipeline, allowing scientists to focus on their models and results rather than on the underlying software implementation.</p><p>The framework is built on three core pillars:</p><ul><li><p><strong>A Unified Interface:</strong> It integrates simulation, advanced ergodic analysis, and interactive visualization into a single, intuitive API.</p></li><li><p><strong>Performance by Design:</strong> It leverages a powerful Rust backend for all computationally intensive tasks, delivering the speed of compiled code without sacrificing the ease-of-use of Python.</p></li><li><p><strong>Accessibility:</strong> The API is intentionally designed to be &ldquo;Pythonic&rdquo; and familiar to users of the SciPy stack, lowering the barrier to entry for sophisticated dynamical analysis.</p></li></ul><p>The following overview demonstrates how these principles come together in practice, walking through a typical user&rsquo;s journey from defining a system to analyzing its chaotic nature.</p><h3 id=1-high-level-overview-the-user><strong>1. High-Level Overview: The User&rsquo;s Journey</strong></h3><p>The central philosophy of <code>DynamiXplore</code> is to separate the <em>definition</em> of a system from its <em>simulation</em> and <em>analysis</em>. This modularity allows researchers to focus on their specific problem without reinventing the numerical backend.</p><p>A typical user workflow would look like this in Python:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>dynamixplore</span> <span class=k>as</span> <span class=nn>dx</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 1. DEFINE the dynamical system (e.g., Lorenz Attractor)</span>
</span></span><span class=line><span class=cl><span class=c1># The user provides a standard Python function.</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>lorenz_system</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>state</span><span class=p>,</span> <span class=n>sigma</span><span class=o>=</span><span class=mf>10.0</span><span class=p>,</span> <span class=n>rho</span><span class=o>=</span><span class=mf>28.0</span><span class=p>,</span> <span class=n>beta</span><span class=o>=</span><span class=mi>8</span><span class=o>/</span><span class=mi>3</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span> <span class=o>=</span> <span class=n>state</span>
</span></span><span class=line><span class=cl>    <span class=n>dx_dt</span> <span class=o>=</span> <span class=n>sigma</span> <span class=o>*</span> <span class=p>(</span><span class=n>y</span> <span class=o>-</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dy_dt</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=p>(</span><span class=n>rho</span> <span class=o>-</span> <span class=n>z</span><span class=p>)</span> <span class=o>-</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>    <span class=n>dz_dt</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>-</span> <span class=n>beta</span> <span class=o>*</span> <span class=n>z</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=n>dx_dt</span><span class=p>,</span> <span class=n>dy_dt</span><span class=p>,</span> <span class=n>dz_dt</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. CONFIGURE the simulation</span>
</span></span><span class=line><span class=cl><span class=c1># Set initial conditions, time span, and select a solver.</span>
</span></span><span class=line><span class=cl><span class=n>initial_state</span> <span class=o>=</span> <span class=p>[</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>t_span</span> <span class=o>=</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>200</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>dt</span> <span class=o>=</span> <span class=mf>0.01</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># The `Simulation` object orchestrates the call to the Rust backend.</span>
</span></span><span class=line><span class=cl><span class=n>sim</span> <span class=o>=</span> <span class=n>dx</span><span class=o>.</span><span class=n>Simulation</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>system_dynamics</span><span class=o>=</span><span class=n>lorenz_system</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>initial_state</span><span class=o>=</span><span class=n>initial_state</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>t_span</span><span class=o>=</span><span class=n>t_span</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>dt</span><span class=o>=</span><span class=n>dt</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>solver</span><span class=o>=</span><span class=s1>&#39;RK45&#39;</span> <span class=c1># Choose a high-performance adaptive solver</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. SIMULATE the system</span>
</span></span><span class=line><span class=cl><span class=c1># This call executes the high-performance Rust core.</span>
</span></span><span class=line><span class=cl><span class=n>trajectory</span> <span class=o>=</span> <span class=n>sim</span><span class=o>.</span><span class=n>run</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># `trajectory` is a standard NumPy array for immediate use.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 4. ANALYZE the results</span>
</span></span><span class=line><span class=cl><span class=c1># Create an analysis object from the trajectory data.</span>
</span></span><span class=line><span class=cl><span class=n>analysis</span> <span class=o>=</span> <span class=n>dx</span><span class=o>.</span><span class=n>Analysis</span><span class=p>(</span><span class=n>trajectory</span><span class=p>,</span> <span class=n>dt</span><span class=o>=</span><span class=n>dt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Compute various ergodic and information-theoretic properties.</span>
</span></span><span class=line><span class=cl><span class=c1># Each of these methods calls a specialized, parallelized Rust function.</span>
</span></span><span class=line><span class=cl><span class=n>lyapunov_spectrum</span> <span class=o>=</span> <span class=n>analysis</span><span class=o>.</span><span class=n>lyapunov_spectrum</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>invariant_measure_hist</span><span class=p>,</span> <span class=n>bins</span> <span class=o>=</span> <span class=n>analysis</span><span class=o>.</span><span class=n>invariant_measure</span><span class=p>(</span><span class=n>dims</span><span class=o>=</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>],</span> <span class=n>bins</span><span class=o>=</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>perm_entropy</span> <span class=o>=</span> <span class=n>analysis</span><span class=o>.</span><span class=n>permutation_entropy</span><span class=p>(</span><span class=n>dim</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=n>delay</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ks_entropy_est</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>([</span><span class=n>le</span> <span class=k>for</span> <span class=n>le</span> <span class=ow>in</span> <span class=n>lyapunov_spectrum</span> <span class=k>if</span> <span class=n>le</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>])</span> <span class=c1># Kaplan-Yorke conjecture</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 5. VISUALIZE</span>
</span></span><span class=line><span class=cl><span class=c1># Use built-in, high-level plotting functions.</span>
</span></span><span class=line><span class=cl><span class=n>fig1</span> <span class=o>=</span> <span class=n>dx</span><span class=o>.</span><span class=n>visualize</span><span class=o>.</span><span class=n>plot_phase_portrait</span><span class=p>(</span><span class=n>trajectory</span><span class=p>,</span> <span class=n>dims</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;x&#39;</span><span class=p>,</span> <span class=s1>&#39;y&#39;</span><span class=p>,</span> <span class=s1>&#39;z&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>fig2</span> <span class=o>=</span> <span class=n>dx</span><span class=o>.</span><span class=n>visualize</span><span class=o>.</span><span class=n>plot_lyapunov_convergence</span><span class=p>(</span><span class=n>analysis</span><span class=o>.</span><span class=n>lyapunov_history</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>fig3</span> <span class=o>=</span> <span class=n>dx</span><span class=o>.</span><span class=n>visualize</span><span class=o>.</span><span class=n>plot_invariant_measure</span><span class=p>(</span><span class=n>invariant_measure_hist</span><span class=p>,</span> <span class=n>bins</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Lyapunov Spectrum: </span><span class=si>{</span><span class=n>lyapunov_spectrum</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Estimated KS-Entropy: </span><span class=si>{</span><span class=n>ks_entropy_est</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Permutation Entropy: </span><span class=si>{</span><span class=n>perm_entropy</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># fig1.show()</span>
</span></span></code></pre></div><p>This workflow is intuitive for anyone familiar with the SciPy ecosystem but provides a significant performance boost and advanced analysis features not available in standard libraries.</p><hr><h3 id=2-application-architecture-the-python-rust-hybrid-model><strong>2. Application Architecture: The Python-Rust Hybrid Model</strong></h3><p>The architecture is designed to maximize the user-friendliness of Python and the computational performance of Rust.</p><h4 id=layer-1-python-user-facing-layer><strong>Layer 1: Python User-Facing Layer</strong></h4><ul><li><p><strong>Role:</strong> High-level API, orchestration, data handling, and visualization.</p></li><li><p><strong>Components:</strong></p><ul><li><p><strong><code>dynamixplore</code> (Main Package):</strong></p><ul><li><code>Simulation</code>: A class to configure and run simulations. It takes user-defined Python functions and parameters.</li><li><code>Analysis</code>: A class that takes simulation data (as NumPy arrays) and provides methods for analysis (e.g., <code>lyapunov_spectrum()</code>, <code>permutation_entropy()</code>).</li><li><code>visualize</code>: A submodule built on <strong>Matplotlib</strong> and <strong>Plotly</strong> for publication-quality static and interactive plots.</li></ul></li><li><p><strong>Data Structures:</strong> Primarily <strong>NumPy</strong> arrays. This ensures zero-copy data transfer between Python and Rust.</p></li><li><p><strong>Symbolic Helper (Optional but powerful):</strong> Integration with <strong>SymPy</strong> to allow users to define systems via strings, which are then JIT-compiled into fast numerical functions using <code>sympy.lambdify</code>.</p></li></ul></li></ul><h4 id=layer-2-the-bridge-pyo3><strong>Layer 2: The Bridge (PyO3)</strong></h4><ul><li><p><strong>Role:</strong> To create seamless, low-overhead bindings between Python and Rust.</p></li><li><p><strong>Technology: PyO3</strong>.</p></li><li><p><strong>Implementation:</strong> A <code>lib.rs</code> file in the Rust crate will define <code>#[pyfunction]</code> wrappers. These functions will be compiled into a native Python extension module (<code>.so</code>, <code>.pyd</code>). PyO3 handles all the type conversions (e.g., Python lists/NumPy arrays to Rust <code>Vec&lt;f64></code> or <code>ndarray::Array</code>).</p></li></ul><h4 id=layer-3-rust-core-engine-><strong>Layer 3: Rust Core Engine (<code>dx_core</code>)</strong></h4><ul><li><p><strong>Role:</strong> The computational powerhouse. This is a compiled Rust library (<code>crate</code>) that contains all the numerically intensive algorithms.</p></li><li><p><strong>Components/Modules:</strong></p><ul><li><p><strong><code>integrators</code>:</strong></p><ul><li>Implements various ODE solvers (e.g., Forward Euler, RK4, RK45 Dormand-Prince). These operate on a generic trait <code>DynamicalSystem</code> so they can be reused.</li><li>Tools: <strong><code>ndarray</code></strong> for state vectors.</li></ul></li><li><p><strong><code>lyapunov</code>:</strong></p><ul><li>Implements algorithms to compute the maximal Lyapunov exponent and the full Lyapunov spectrum (e.g., using continuous QR decomposition).</li><li>This module will repeatedly call the <code>integrators</code> to evolve multiple nearby trajectories.</li><li>Tools: <strong><code>nalgebra</code></strong> for linear algebra operations (QR decomposition).</li></ul></li><li><p><strong><code>entropy</code>:</strong></p><ul><li><code>permutation_entropy</code>: A fast implementation for analyzing time-series complexity.</li><li><code>shannon_entropy</code>: Calculates entropy from a probability distribution (e.g., the invariant measure).</li></ul></li><li><p><strong><code>stats</code>:</strong></p><ul><li><code>invariant_measure</code>: A highly optimized, multi-dimensional histogramming function to estimate the invariant measure from a long trajectory.</li></ul></li><li><p><strong><code>parallel</code>:</strong></p><ul><li>Leverages <strong>Rayon</strong> for easy, data-parallelism. For example, computing Lyapunov exponents for a range of parameters or analyzing independent trajectories can be done in parallel with a single line of code change in Rust (<code>.iter()</code> -> <code>.par_iter()</code>).</li></ul></li></ul></li></ul></div></article></main><footer class=site-footer><p>&copy; <span id=currentYear>2025</span> Daniel Dia. All rights reserved.</p><p>Powered by
<a href=https://gohugo.io/ class="text-custom-red-500 hover:underline" target=_blank rel="noopener noreferrer">Hugo</a>,
<a href=https://tailwindcss.com/ class="text-custom-red-500 hover:underline" target=_blank rel="noopener noreferrer">Tailwind CSS</a>,
<a href=https://www.goatcounter.com/ class="text-custom-red-500 hover:underline" target=_blank rel="noopener noreferrer">GoatCounter</a>
&
<a href=https://pages.github.com/ class="text-custom-red-500 hover:underline" target=_blank rel="noopener noreferrer">GitHub Pages</a></p></footer><script>document.addEventListener("DOMContentLoaded",()=>{const t=document.querySelectorAll("header nav a.nav-link"),n=window.location.pathname;let e={link:null,length:-1};t.forEach(t=>{t.classList.remove("active","text-custom-red-500","bg-custom-red-200","font-semibold"),t.classList.add("text-custom-gray-700");let s=new URL(t.href).pathname;s.length>1&&s.endsWith("/")&&(s=s.slice(0,-1));let o=n;o.length>1&&o.endsWith("/")&&(o=o.slice(0,-1)),(o===s||s!=="/"&&o.startsWith(s+"/"))&&s.length>e.length&&(e.link=t,e.length=s.length)}),e.link&&(e.link.classList.add("active","text-custom-red-500","bg-custom-red-200","font-semibold"),e.link.classList.remove("text-custom-gray-700"))})</script><script data-goatcounter=https://danieldia.goatcounter.com/count async src=//gc.zgo.at/count.js></script><noscript><img src="https://danieldia.goatcounter.com/count?p=/portfolio/dynamixplore" alt></noscript></body></html>